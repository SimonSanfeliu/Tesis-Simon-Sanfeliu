# As a SQL you are tasked with crafting a PostgreSQL query for the Automatic Learning for the Rapid Classification of Events (ALeRCE) database. This database serves as a repository for information about astronomical variable objects. The database information includes flux variations as a function of time (known as light curve), basic object properties such as the coordinates, and advanced features or statistics computed for each object.
The tables within the database are categorized into three types: time and band independent (e.g., object and probability), time-independent (e.g., magstats), and time and band-dependent (e.g., detection, forced-photometry). Your role involves carefully analyzing user requests, considering the specifics of the given tables. It is crucial to pay attention to explicit conditions outlined by the user and always maintain awareness of the broader context.
Be thorough in understanding and addressing the user's request, taking into account both explicit conditions and the overall context for effective communication and assistance.

User request: Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.
Tables needed: [object, probability, detection, feature]

## Default Parameters to Consider
- Class probabilities for a given classifier and object are sorted from most to least likely, where the relative position is indicated by the 'ranking' column in the probability table. Hence, the most probable class should have 'ranking'=1.
- The ALeRCE classification pipeline includes a Stamp Classifier and a Light Curve Classifier. The Light Curve classifier employs a hierarchical classification. If no classifier is specified, use 'classifier_name=â€™lc_classifierâ€™ when selecting probabilities.
- If the user doesn't specify explicit columns, use the "SELECT" SQL statement to choose all possible columns.
- Avoid changing the names of columns or tables unless necessary for the SQL query.
- Use the exact class names as they are in the database, marked with single quotes, for example, 'SNIa'.

### IF THE 'feature' TABLE is used with 2 or more features, you need to take the following steps, because it is a transposed table (each feature is in a different row).
I. Create a sub-query using the 'probability' TABLE filtering the desired objects.
II. For each feature, you have to make a sub-query retrieving the specific feature adding the condition of its value, including an INNER JOIN with the 'probability' sub-query to retrieve only the features associated with the desired spatial objects.
III. Make an UNION between the sub-queries of each feature from step II
IV. Make an INTERSECT between the sub-queries of each feature from step II
V. Filter the UNION query selecting the 'oids' in the INTERSECT query
VI. Add to the final result from step V the remaining conditions

### GENERAL
- If the user doesn't specify explicit columns or information that is not in a column, choose all the columns, for example by using the "SELECT" SQL statement.
- Use the exact class names as they are in the database, marked with single quotes, for example, 'SNIa'.
# If you need to use 2 or 3 tables, try using a sub-query over 'probability' TABLE, 'object' TABLE, over an INNER JOIN between 'probability' and 'object', or over an INNER JOIN between 'probability', 'object' and 'magstat', if it is necessary (in this order).
# Add COMMENTS IN Python format so that the user can understand.

# Generate a query for each step, resolving and analysing it, with the following format:
'''python [VARIABLE SUB-QUERY HERE] '''
# Finally, join all the steps in a final query like so: 
'''python full_query = [FINAL QUERY HERE] '''
DON'T include anything else inside and after your FINAL answer.

# Guide yourself by this example for the next query
## Query: Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.
## Resulting Python code:
sub_query_object=f'''
SELECT
    object.oid, probability.probability
FROM
    object INNER JOIN
    probability
    ON object.oid = probability.oid
WHERE
    probability.classifier_name='stamp_classifier'
    AND probability.class_name='SN'
    AND probability.ranking=1
    AND object.firstmjd > 60188.0
    AND object.firstmjd < 60189.0
'''

sub_query_detection=f'''
SELECT
  detection.oid, detection.candid, detection.fid, detection.mjd,
  obj_oids.probability
FROM
  ({sub_query_object}) as obj_oids
    INNER JOIN
    detection ON detection.oid = obj_oids.oid
'''

### detections
query=f'''
SELECT
    sq.oid, sq.probability, sq.candid, sq.fid, sq.mjd,
    magstat.fid as magstat_fid, magstat.dmdt_first
FROM
  ({sub_query_detection}) AS sq
  INNER JOIN magstat
  ON sq.oid = magstat.oid
WHERE
  magstat.dmdt_first < -0.25
ORDER BY oid
'''

# Use the next decomposed planification to write the query:
### 1. [Initial Planning]
- **Objective**: Retrieve object identifiers (oids), probabilities from the stamp classifier, and light curve data (only detections) for objects with the highest probability for class 'SN' in the stamp classifier, their first detection within the first two days of September, and classified as fast risers.
- **Main Tables Involved**: 
  - **object**: To filter objects based on first detection date and retrieve `oid`.
  - **probability**: To filter objects based on the highest probability for class 'SN' using the stamp classifier.
  - **detection**: To retrieve light curve information (detections only).
  - **feature**: To qualify objects as fast risers.

### 2. [Sub-query] Filter Objects by First Detection in September
- **Objective**: Get object identifiers (`oid`) of objects that had their first detection in the first two days of September.
- **Table**: `object`
- **Condition**: Use the `firstmjd` column to filter objects where the `firstmjd` corresponds to the first two days of September. You'll need to convert this to a Julian Date format to handle the dates correctly.
- **Details**: 
  ```sql
  SELECT oid 
  FROM object 
  WHERE firstmjd BETWEEN [Julian date for September 1st] AND [Julian date for September 2nd]
  ```

### 3. [Sub-query] Filter by Highest Probability for Class 'SN' in Stamp Classifier
- **Objective**: Retrieve objects whose highest classification probability is for class 'SN' using the stamp classifier.
- **Table**: `probability`
- **Condition**: The `class_name` must be 'SN' and the `classifier_name` must be 'stamp_classifier'. Filter only the objects where the `ranking` is 1, which corresponds to the highest probability.
- **Details**: 
  ```sql
  SELECT oid, probability 
  FROM probability 
  WHERE class_name = 'SN' 
    AND classifier_name = 'stamp_classifier' 
    AND ranking = 1
  ```

### 4. [Join] Combine First Detection and Highest Probability
- **Objective**: Combine the results from Step 2 and Step 3 to retrieve only the `oid`s that satisfy both conditions (i.e., objects that had their first detection in the first two days of September and whose highest classification probability is 'SN').
- **Details**: Use an INNER JOIN between the subqueries of Step 2 and Step 3.
  ```sql
  SELECT oid, probability 
  FROM (Sub-query from Step 2) 
  INNER JOIN (Sub-query from Step 3) USING (oid)
  ```

### 5. [Sub-query] Filter Objects Qualifying as Fast Risers
- **Objective**: Identify objects classified as "fast risers" based on features stored in the `feature` table.
- **Table**: `feature`
- **Condition**: Filter objects where the feature `name` is associated with the conditions for fast risers, such as `delta_mag_fid`, `dmag_first_det_fid`, or other features that describe a rapid rise in brightness.
- **Details**: Create a subquery to select objects that meet these fast riser feature thresholds.
  ```sql
  SELECT oid 
  FROM feature 
  WHERE name = 'delta_mag_fid' AND value > [threshold for fast riser]
  ```

### 6. [Intersect] Filter by Fast Riser Criteria
- **Objective**: Narrow down the results from Step 4 to include only objects that qualify as fast risers.
- **Details**: Perform an INTERSECT between the results of Step 4 and the subquery from Step 5 to select only those objects that meet both the first detection date, highest probability, and fast riser criteria.
  ```sql
  SELECT oid, probability 
  FROM (Sub-query from Step 4) 
  INTERSECT 
  SELECT oid 
  FROM (Sub-query from Step 5)
  ```

### 7. [Join] Retrieve Light Curve Data for Detections
- **Objective**: Get the light curve data (detections) for the objects filtered in Step 6.
- **Table**: `detection`
- **Condition**: Retrieve the detection data (`mjd`, `magpsf`, `sigmapsf`, etc.) for the objects whose `oid` was selected in Step 6. Ensure that only positive detections (`isdiffpos = 1`) are retrieved.
- **Details**: Use an INNER JOIN to link the filtered `oid`s with the `detection` table to retrieve the light curve data.
  ```sql
  SELECT d.oid, d.mjd, d.magpsf, d.sigmapsf 
  FROM detection d 
  INNER JOIN (Sub-query from Step 6) USING (oid) 
  WHERE d.isdiffpos = 1
  ```

### 8. [Final Output] Aggregate the Results
- **Objective**: Combine the object identifiers, probabilities, and detection data in the final output.
- **Details**: The final result should include the `oid`, `probability` (from the stamp classifier), and the light curve data (`mjd`, `magpsf`, `sigmapsf`) for detections.
  ```sql
  SELECT d.oid, p.probability, d.mjd, d.magpsf, d.sigmapsf 
  FROM (Sub-query from Step 7) d 
  INNER JOIN (Sub-query from Step 6) p ON d.oid = p.oid
  ```

### 9. [Optimization] Ensure Indexing
- **Objective**: To avoid performance issues, ensure the subqueries are optimized using indexed columns such as `oid` and `ranking` (for the `probability` table).
- **Details**: The subqueries should prioritize filtering by indexed columns before any additional filtering steps (e.g., filtering on `class_name`, `ranking` in the `probability` table).

### 10. [Final Review]
- **Objective**: Ensure that the query does not exceed the time limits and is structured in an optimal way by avoiding unnecessary JOINs and prioritizing nested subqueries with indexed fields.
- **Details**: The query plan should be reviewed for performance issues, making sure no non-indexed columns are filtered before indexed ones, and avoiding excessive JOINs by focusing on subqueries.

# If there is SQL code, use it only as reference, changing the conditions you consider necessary.
# You can join some of the steps if you consider it better for the query. For example, if 2 or more use the same table and are not requested to be different sub-queries, then you can join them.