# As a SQL you are tasked with crafting a PostgreSQL query for the Automatic Learning for the Rapid Classification of Events (ALeRCE) database. This database serves as a repository for information about astronomical variable objects. The database information includes flux variations as a function of time (known as light curve), basic object properties such as the coordinates, and advanced features or statistics computed for each object.
The tables within the database are categorized into three types: time and band independent (e.g., object and probability), time-independent (e.g., magstats), and time and band-dependent (e.g., detection, forced-photometry). Your role involves carefully analyzing user requests, considering the specifics of the given tables. It is crucial to pay attention to explicit conditions outlined by the user and always maintain awareness of the broader context.
Be thorough in understanding and addressing the user's request, taking into account both explicit conditions and the overall context for effective communication and assistance.

User request: Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.
Tables needed: [object, probability, detection, feature]

## Default Parameters to Consider
- Class probabilities for a given classifier and object are sorted from most to least likely, where the relative position is indicated by the 'ranking' column in the probability table. Hence, the most probable class should have 'ranking'=1.
- The ALeRCE classification pipeline includes a Stamp Classifier and a Light Curve Classifier. The Light Curve classifier employs a hierarchical classification. If no classifier is specified, use 'classifier_name=â€™lc_classifierâ€™ when selecting probabilities.
- If the user doesn't specify explicit columns, use the "SELECT" SQL statement to choose all possible columns.
- Avoid changing the names of columns or tables unless necessary for the SQL query.
- Use the exact class names as they are in the database, marked with single quotes, for example, 'SNIa'.

### IF THE 'feature' TABLE is used with 2 or more features, you need to take the following steps, because it is a transposed table (each feature is in a different row).
I. Create a sub-query using the 'probability' TABLE filtering the desired objects.
II. For each feature, you have to make a sub-query retrieving the specific feature adding the condition of its value, including an INNER JOIN with the 'probability' sub-query to retrieve only the features associated with the desired spatial objects.
III. Make an UNION between the sub-queries of each feature from step II
IV. Make an INTERSECT between the sub-queries of each feature from step II
V. Filter the UNION query selecting the 'oids' in the INTERSECT query
VI. Add to the final result from step V the remaining conditions

### GENERAL
- If the user doesn't specify explicit columns or information that is not in a column, choose all the columns, for example by using the "SELECT" SQL statement.
- Use the exact class names as they are in the database, marked with single quotes, for example, 'SNIa'.
# If you need to use 2 or 3 tables, try using a sub-query over 'probability' TABLE, 'object' TABLE, over an INNER JOIN between 'probability' and 'object', or over an INNER JOIN between 'probability', 'object' and 'magstat', if it is necessary (in this order).
# Add COMMENTS IN Python format so that the user can understand.

# Generate a query for each step, resolving and analysing it, with the following format:
'''python [VARIABLE SUB-QUERY HERE] '''
# Finally, join all the steps in a final query like so: 
'''python full_query = [FINAL QUERY HERE] '''
DON'T include anything else inside and after your FINAL answer.

# Guide yourself by this example for the next query
## Query: Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.
## Resulting Python code:
sub_query_object=f'''
SELECT
    object.oid, probability.probability
FROM
    object INNER JOIN
    probability
    ON object.oid = probability.oid
WHERE
    probability.classifier_name='stamp_classifier'
    AND probability.class_name='SN'
    AND probability.ranking=1
    AND object.firstmjd > {mjd_first_16}
    AND object.firstmjd < {mjd_last_16}
'''

sub_query_detection=f'''
SELECT
  detection.oid, detection.candid, detection.fid, detection.mjd,
  obj_oids.probability
FROM
  ({sub_query_object}) as obj_oids
    INNER JOIN
    detection ON detection.oid = obj_oids.oid
'''

### detections
query=f'''
SELECT
    sq.oid, sq.probability, sq.candid, sq.fid, sq.mjd,
    magstat.fid as magstat_fid, magstat.dmdt_first
FROM
  ({sub_query_detection}) AS sq
  INNER JOIN magstat
  ON sq.oid = magstat.oid
WHERE
  magstat.dmdt_first < -0.25
ORDER BY oid
'''

# Use the next decomposed planification to write the query:
---

### Step 1: [initial planning] Define the problem and establish subqueries
The request involves several conditions related to objects, classifications, and detections. The main goal is to retrieve **object identifiers**, **probabilities** in the **stamp classifier**, and **light curves (detections)** for **objects** with the following conditions:
  - The highest probability is for class **'SN'** in the **stamp classifier**.
  - The object had its first detection in the first two days of September.
  - The object qualifies as a **fast riser** based on the **light curve features**.

---

### Step 2: [sub-query] Retrieve objects classified as **SN** by the **stamp classifier**
  - **Table:** 'probability'
  - **Columns:** 'oid', 'class_name', 'classifier_name', 'ranking', 'probability'
  - **Conditions:**
    - **class_name** = 'SN' (specific to supernova class)
    - **classifier_name** = 'stamp_classifier' (only interested in the stamp classifier)
    - **ranking** = 1 (the object must have the highest probability for class 'SN')
  
  In this subquery, filter for objects classified as 'SN' by ensuring that 'ranking' is equal to 1, and retrieve the corresponding 'oid' and 'probability'.

---

### Step 3: [sub-query] Filter objects with first detection in the first two days of September
  - **Table:** 'detection'
  - **Columns:** 'oid', 'mjd'
  - **Condition:** Convert the **Modified Julian Date (MJD)** to a calendar date format (e.g., September 1-2) using PostgreSQL date functions.
    - Use 'mjd' from the 'detection' table, applying a filter for objects where the first detection occurred within the first two days of September. This would likely require a conversion function such as 'to_timestamp()' to compare the date range.

Create a subquery that retrieves 'oid' for objects with first detection on September 1st and 2nd by filtering the **mjd** (Modified Julian Date) column.

---

### Step 4: [condition] Identify objects qualifying as **fast risers** based on features
  - **Table:** 'feature'
  - **Columns:** 'oid', 'name', 'value'
  - **Condition:** Retrieve specific features that define "fast risers" (these may be derived from the feature names such as 'dmdt_first', 'dm_first', 'delta_mjd_fid' or other suitable feature columns). Fast risers are typically characterized by large magnitude changes in short time intervals.
  
  Filter for objects that satisfy the "fast riser" criteria by selecting the required features from the 'feature' table. Specifically, use the **name** and **value** fields to retrieve features such as:
    - 'dmdt_first': Change in magnitude
    - 'dm_first': Magnitude difference at first detection
    - 'delta_mjd_fid': Time difference between first and subsequent detections.
  
  Use these conditions to filter objects that meet the "fast riser" criteria.

---

### Step 5: [sub-query] Retrieve light curves (detections) for filtered objects
  - **Table:** 'detection'
  - **Columns:** 'oid', 'magpsf', 'mjd'
  - **Conditions:** 
    - Filter for detections with 'isdiffpos=1' (only positive detections).
  
  After filtering for qualifying objects (i.e., those classified as **SN**, detected in the first two days of September, and qualifying as fast risers), retrieve the **light curves** (detections) for these objects by selecting the **mjd**, **magpsf** (point spread function magnitude), and other necessary light curve details from the 'detection' table.

---

### Step 6: [join] Combine the results from subqueries
  - **JOIN** the subqueries from the 'probability', 'detection', and 'feature' tables on the common 'oid' (object identifier) to create the final result set.
  - In the outermost query, you will need to ensure the following:
    - The **probability** subquery provides the **classification** and **probability** for class 'SN'.
    - The **detection** subquery retrieves the **light curves** (positive detections).
    - The **feature** subquery checks for objects that qualify as **fast risers**.
    - Make sure to use **INTERSECT** between the subqueries when necessary, as the 'feature' and 'probability' subqueries must return objects common to both conditions (fast riser and SN classification).

---

### Step 7: [output] Final SELECT statement for the query
  - **SELECT** the necessary columns:
    - **Object identifiers** ('oid')
    - **Probability** ('probability' from 'probability' table)
    - **Light curves** ('magpsf', 'mjd' from 'detection' table)

Ensure that the final query selects the appropriate fields from each subquery, filtered by the conditions outlined, and joins them using **nested subqueries** for optimal performance (based on the schema context).

---

### Step 8: [comment] Add explanations for clarity
  - Include comments in the PostgreSQL query to describe each section of the query, clarifying why certain filters, joins, and subqueries were applied.

# If there is SQL code, use it only as reference, changing the conditions you consider necessary.
# You can join some of the steps if you consider it better for the query. For example, if 2 or more use the same table and are not requested to be different sub-queries, then you can join them.