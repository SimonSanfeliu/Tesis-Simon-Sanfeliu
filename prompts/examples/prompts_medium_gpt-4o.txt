{'Schema Linking': {'ragInstruction': ' Given the user request, search for the tables needed\n    to generate a SQL query in the ALeRCE database (PostgreSQL).\n    \n Request: Get the object identifiers and probabilities in the light curve classifier for objects classified in the light curve classifier as SNIa with ranking=1 and CV/Nova with ranking=2, where the difference between the probabilities at each ranking is lower than 0.1. Return oids, and the probability for each class', 'Used prompt': 'Given the user request, select the tables needed to \n    generate a SQL query. Give the answer in the following format: [table1, \n    table2, ...]. For example, if the answer is table object and table \n    taxonomy, then you should type: [object, taxonomy].\n    \n    Consider that these tables are necessary to execute the query: \n\nThe necessary tables to generate this SQL query would be "probability" and "feature". The table "probability" contains the classification probabilities, while the table "feature" contains the object light curve.'}, 'Classification': 'Get the object identifiers and probabilities in the light curve classifier for objects classified in the light curve classifier as SNIa with ranking=1 and CV/Nova with ranking=2, where the difference between the probabilities at each ranking is lower than 0.1. Return oids, and the probability for each class\n The following tables are needed to generate the\n    query: [probability, feature]', 'Decomposition': "\n\n# As a SQL expert with a willingness to assist users, you are tasked with crafting a PostgreSQL query for the Automatic Learning for the Rapid Classification of Events (ALeRCE) database. This database serves as a repository for information about astronomical variable objects. The information for every variable object originates from a sequence of one or more astronomical alerts, data packets streamed when an astronomical object shows a significant variation with respect to a reference image. The database information includes flux variations as a function of time (known as light curve), basic object properties such as the coordinates, and advanced features or statistics computed for each object.\nThe tables within the database are categorized into three types: time and band independent (e.g., object and probability), time-independent (e.g., magstats), and time and band-dependent (e.g., detection, forced-photometry). Your role involves carefully analyzing user requests, considering the specifics of the given tables. It is crucial to pay attention to explicit conditions outlined by the user and always maintain awareness of the broader context.\nBe thorough in understanding and addressing the user's request, taking into account both explicit conditions and the overall context for effective communication and assistance.\n\nGet the object identifiers and probabilities in the light curve classifier for objects classified in the light curve classifier as SNIa with ranking=1 and CV/Nova with ranking=2, where the difference between the probabilities at each ranking is lower than 0.1. Return oids, and the probability for each class\n The following tables are needed to generate the\n    query: [probability, feature]\n\n## Default Parameters to Consider\n- Class probabilities for a given classifier and object are sorted from most to least likely, where the relative position is indicated by the 'ranking' column in the probability table. Hence, the most probable class should have 'ranking'=1.\n- The ALeRCE classification pipeline includes a Stamp Classifier and a Light Curve Classifier. The Light Curve classifier employs a hierarchical classification. If no classifier is specified, use 'classifier_name=â€™lc_classifierâ€™ when selecting probabilities.\n- If the user doesn't specify explicit columns, use the â€œSELECT *â€\x9d SQL statement to choose all possible columns.\n- Avoid changing the names of columns or tables unless necessary for the SQL query.\n- Use the exact class names as they are in the database, marked with single quotes, for example, 'SNIa'.\n\n### IF THE 'feature' TABLE is used with 2 or more features, you need to take the following steps, because it is a transposed table (each feature is in a different row).\nI. Create a sub-query using the 'probability' TABLE filtering the desired objects.\nII. For each feature, you have to make a sub-query retrieving the specific feature adding the condition of its value, including an INNER JOIN with the 'probability' sub-query to retrieve only the features associated with the desired spatial objects.\nIII. Make an UNION between the sub-queries of each feature from step II\nIV. Make an INTERSECT between the sub-queries of each feature from step II\nV. Filter the UNION query selecting the 'oids' in the INTERSECT query\nVI. Add to the final result from step V the remaining conditions\n\n### GENERAL\n- If the user doesn't specify explicit columns or information that is not in a column, choose all the columns, for example by using the â€œSELECT *â€\x9d SQL statement.\n- Use the exact class names as they are in the database, marked with single quotes, for example, 'SNIa'.\n# If you need to use 2 or 3 tables, try using a sub-query over 'probability' TABLE, 'object' TABLE, over an INNER JOIN between 'probability' and 'object', or over an INNER JOIN between 'probability', 'object' and 'magstat', if it is necessary (in this order).\n# Add COMMENTS IN PostgreSQL format so that the user can understand.\n\n# Generate a query for each step, resolving and analysing it, with the following format:\n```step_number [STEP QUERY HERE] ```\n# Finally, join all the steps in a final query, with the following format: \n```sql [FINAL QUERY HERE] ```\nDON'T include anything else inside and after your FINAL answer.\n\n# Use the next decomposed planification to write the query:\nTo generate the required PostgreSQL query for retrieving object identifiers and probabilities for objects classified in the light curve classifier as SNIa with ranking=1 and CV/Nova with ranking=2, where the difference between the probabilities at each ranking is lower than 0.1, follow these detailed steps:\n\n1. **[Initial Planning]**: \n   - Identify the main tables involved: `probability` and `feature`.\n   - Focus on the `probability` table for initial filtering since it contains indexed columns like `oid`, `classifier_name`, `class_name`, and `ranking`.\n\n2. **[Sub-query for SNIa]**:\n   - Create a sub-query to select `oids` from the `probability` table where `classifier_name` is 'lc_classifier', `class_name` is 'SNIa', and `ranking` is 1.\n   - Ensure to select the `oid` and `probability` columns for further comparison.\n\n3. **[Sub-query for CV/Nova]**:\n   - Create another sub-query to select `oids` from the `probability` table where `classifier_name` is 'lc_classifier', `class_name` is 'CV/Nova', and `ranking` is 2.\n   - Again, select the `oid` and `probability` columns.\n\n4. **[Join and Condition]**:\n   - Use a nested query to join the results of the SNIa and CV/Nova sub-queries on `oid`.\n   - Add a condition to filter the joined results where the absolute difference between the probabilities of SNIa and CV/Nova is less than 0.1.\n\n5. **[Final Selection]**:\n   - From the filtered results, select the `oid` and the probabilities for both SNIa and CV/Nova.\n   - Ensure to include all relevant columns as per the requirement, using `SELECT *` if necessary.\n\n6. **[Feature Table Consideration]**:\n   - If additional features are needed from the `feature` table, create separate sub-queries for each feature.\n   - Use an INNER JOIN with the filtered `oid` results to ensure only relevant features are retrieved.\n   - Use UNION and INTERSECT as necessary to combine and filter feature results, ensuring only the `oids` from the INTERSECT query are selected.\n\n7. **[Comments and Optimization]**:\n   - Add comments in PostgreSQL format to explain each part of the query for clarity.\n   - Ensure the query is optimized by using indexed columns in the sub-queries and minimizing the use of JOINs.\n\nBy following these steps, you will systematically construct a complex query that efficiently retrieves the desired information from the ALeRCE database, adhering to the constraints and optimizations outlined in the general context.\n# If there is SQL code, use it only as reference, changing the conditions you consider necessary.\n# You can join some of the steps if you consider it better for the query. For example, if 2 or more use the same table and are not requested to be different sub-queries, then you can join them.\n"}