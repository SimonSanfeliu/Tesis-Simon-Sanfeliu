{'Schema Linking': "\n    Given the user request, select the tables needed to generate a SQL query. \n    Give the answer in the following format: [table1, table2, ...]. For \n    example, if the answer is table object and table taxonomy, then you should \n    type: [object, taxonomy].\n    \n    User request: Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.\n    \n    ## Astronomical context:\n    There are two main types of variable objects: those that have persistent \n    variability and those that have a transient nature. In the case of \n    persistent variability sources (Periodic or Stochastic), the relevant light \n    curve magnitude is the corrected magnitude (magpsf_corr). In the case of \n    transient sources (Transient), the relevant light curve is the uncorrected \n    magnitude (magpsf). Objects that are transient are considered to be fast \n    risers if dmd_dt < -0.25 mag per day (in magstats) in any band. Note that \n    when the user refers to the first detection of a given object, you should \n    use the firstmjd indexed column (in object). When possible, avoid adding \n    restrictions on the mjd column in the detection table, try putting them in \n    the object table first. Note that all the rows in the detection table are \n    by definition detections, you don't need to ask for additional constraints.\n    ", 'Classification': 'Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.\n The following tables are needed to generate \n    the query: [object, probability, magstat, detection]', 'Decomposition': '\n# As a SQL expert with a willingness to assist users, you are tasked with \ncrafting a PostgreSQL query for the Automatic Learning for the Rapid \nClassification of Events (ALeRCE) database. This database serves as a \nrepository for information about astronomical variable objects. The information \nfor every variable object originates from a sequence of one or more \nastronomical alerts, data packets streamed when an astronomical object shows \na significant variation with respect to a reference image. The database \ninformation includes flux variations as a function of time (known as light \ncurve), basic object properties such as the coordinates, and advanced features \nor statistics computed for each object. The tables within the database are \ncategorized into three types: time and band independent (e.g., object and \nprobability), time-independent (e.g., magstats), and time and band-dependent \n(e.g., detection, forced-photometry). Your role involves carefully analyzing \nuser requests, considering the specifics of the given tables. It is crucial to \npay attention to explicit conditions outlined by the user and always maintain \nawareness of the broader context. Be thorough in understanding and addressing \nthe user\'s request, taking into account both explicit conditions and the \noverall context for effective communication and assistance.\n\nUser request: Get the object identifiers, probabilities in the stamp classifier and light curves (only detections) for objects whose highest probability in the stamp classifier is obtained for class SN, that had their first detection in the first 2 days of september, and that qualify as fast risers.\nTables needed: [object, probability, magstat, detection]\n\n## Default Parameters to Consider\n- Class probabilities for a given classifier and object are sorted from most to \n  least likely, where the relative position is indicated by the \'ranking\' \n  column in the probability table. Hence, the most probable class should have \'ranking\'=1.\n- The ALeRCE classification pipeline includes a Stamp Classifier and a Light \n  Curve Classifier. The Light Curve classifier employs a hierarchical \n  classification. If no classifier is specified, use \n  \'classifier_name="lc_classifier"\' when selecting probabilities.\n- If the user doesn\'t specify explicit columns, use the "SELECT *"\n- Avoid changing the names of columns or tables unless necessary for the SQL query.\n- Use the exact class names as they are in the database, marked with single quotes, for example, \'SNIa\'.\n\n### IF THE \'feature\' TABLE is used with 2 or more features, you need to take \nthe following steps, because it is a transposed table (each feature is in a different row).\nI. Create a sub-query using the \'probability\' TABLE filtering the desired objects.\nII. For each feature, you have to make a sub-query retrieving the specific \n    feature adding the condition of its value, including an INNER JOIN with the \n    \'probability\' sub-query to retrieve only the features associated with the desired spatial objects.\nIII. Make an UNION between the sub-queries of each feature from step II\nIV. Make an INTERSECT between the sub-queries of each feature from step II\nV. Filter the UNION query selecting the \'oids\' in the INTERSECT query\nVI. Add to the final result from step V the remaining conditions\n\n### GENERAL\n- If the user doesn\'t specify explicit columns or information that is not in a \n  column, choose all the columns, for example by using the "SELECT" SQL statement.\n- Use the exact class names as they are in the database, marked with single quotes, for example, \'SNIa\'.\n# If you need to use 2 or 3 tables, try using a sub-query over \'probability\' \nTABLE, \'object\' TABLE, over an INNER JOIN between \'probability\' and \'object\', \nor over an INNER JOIN between \'probability\', \'object\' and \'magstat\', if it is necessary (in this order).\n# Add COMMENTS IN Python format so that the user can understand.\n\n# Generate a query for each step, resolving and analysing it, with the following format:\n```python [VARIABLE SUB-QUERY HERE] ```\n# Finally, join all the steps in a final query like so: \n```python full_query = [FINAL QUERY HERE] ```\nDON\'T include anything else inside and after your FINAL answer.\n\n# Guide yourself by this example for the next query\n## Query: Get the object identifiers, probabilities in the stamp classifier and \nlight curves (only detections) for objects whose highest probability in the \nstamp classifier is obtained for class SN, that had their first detection in \nthe first 2 days of september, and that qualify as fast risers.\n## Resulting Python code:\nsub_query_object=f\'\'\'\nSELECT\n    object.oid, probability.probability\nFROM\n    object INNER JOIN\n    probability\n    ON object.oid = probability.oid\nWHERE\n    probability.classifier_name=\'stamp_classifier\'\n    AND probability.class_name=\'SN\'\n    AND probability.ranking=1\n    AND object.firstmjd > 60188.0\n    AND object.firstmjd < 60189.0\n\'\'\'\n\nsub_query_detection=f\'\'\'\nSELECT\n  detection.oid, detection.candid, detection.fid, detection.mjd,\n  obj_oids.probability\nFROM\n  (sub_query_object) as obj_oids\n    INNER JOIN\n    detection ON detection.oid = obj_oids.oid\n\'\'\'\n\n### detections\nfull_query=f\'\'\'\nSELECT\n    sq.oid, sq.probability, sq.candid, sq.fid, sq.mjd,\n    magstat.fid as magstat_fid, magstat.dmdt_first\nFROM\n  (sub_query_detection) AS sq\n  INNER JOIN magstat\n  ON sq.oid = magstat.oid\nWHERE\n  magstat.dmdt_first < -0.25\nORDER BY oid\n\'\'\'\n\n# Use the next decomposed planification to write the query:\nTo generate the PostgreSQL query for the user request, we need to decompose the problem into a series of systematic steps. The goal is to retrieve object identifiers, probabilities in the stamp classifier, and light curves (only detections) for objects that meet specific criteria. Here is the detailed decomposition plan:\n\n1. **[Initial Planning]**: \n   - Identify the main tables involved: `object`, `probability`, `magstat`, and `detection`.\n   - Determine the key conditions: highest probability in the stamp classifier for class \'SN\', first detection in the first 2 days of September, and qualify as fast risers.\n\n2. **[Sub-query for OIDs with Highest Probability for SN]**:\n   - Create a sub-query to select `oid` from the `probability` table where `classifier_name` is \'stamp_classifier\', `class` is \'SN\', and `ranking` is 1. This ensures we are selecting objects with the highest probability for class \'SN\'.\n\n3. **[Sub-query for First Detection in September]**:\n   - Create a sub-query to select `oid` from the `object` table where `firstmjd` corresponds to the first 2 days of September. Use the appropriate MJD range for these dates.\n\n4. **[Sub-query for Fast Risers]**:\n   - Create a sub-query to select `oid` from the `magstat` table where `dmd_dt` is less than -0.25 in any band (`fid`). This identifies objects that qualify as fast risers.\n\n5. **[Combine OID Conditions]**:\n   - Use an INTERSECT operation to combine the results of the three sub-queries from steps 2, 3, and 4. This will give us the `oid`s that satisfy all conditions: highest probability for \'SN\', first detection in early September, and fast risers.\n\n6. **[Retrieve Probabilities for Selected OIDs]**:\n   - Use the `oid`s obtained from the INTERSECT operation to select relevant columns from the `probability` table. Ensure to filter for `classifier_name` as \'stamp_classifier\'.\n\n7. **[Retrieve Light Curves (Detections) for Selected OIDs]**:\n   - Use the `oid`s from the INTERSECT operation to select relevant columns from the `detection` table. Since all rows in the `detection` table are detections, no additional constraints are needed.\n\n8. **[Final Assembly]**:\n   - Use a UNION operation to combine the results from steps 6 and 7, ensuring that the final output includes object identifiers, probabilities, and light curves for the selected objects.\n\n9. **[Comments and Optimization]**:\n   - Add comments in PostgreSQL format to explain each part of the query for clarity.\n   - Ensure that the query is optimized by using indexed columns and avoiding unnecessary JOINs, as per the general context guidelines.\n\nBy following these steps, we can systematically construct a complex query that retrieves the desired information from the ALeRCE database while adhering to the constraints and optimizations outlined in the general context.\n\n# If there is SQL code, use it only as reference, changing the conditions you consider necessary.\n# You can join some of the steps if you consider it better for the query. For \nexample, if 2 or more use the same table and are not requested to be different sub-queries, then you can join them.\n'}