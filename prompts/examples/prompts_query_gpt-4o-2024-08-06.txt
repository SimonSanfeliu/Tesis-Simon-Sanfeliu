{'Schema Linking': "\n    Given the user request, select the tables needed to generate a SQL query. \n    Give the answer in the following format: [table1, table2, ...]. For \n    example, if the answer is table object and table taxonomy, then you should \n    type: [object, taxonomy].\n    \n    User request: Query objects within 10 degress of the next positions: ('source_1',\n    160.18301441363647, 33.0164673528409), ('source_2', 174.21524897555543, \n    44.83789535222221), that have their first detection the first 7 days of\n    February 2023, with SN probabilities > 0.4, and ranking=1 in the stamp \n    classifier\n    \n    ## Astronomical context:\n    There are two main types of variable objects: those that have persistent \n    variability and those that have a transient nature. In the case of \n    persistent variability sources (Periodic or Stochastic), the relevant light \n    curve magnitude is the corrected magnitude (magpsf_corr). In the case of \n    transient sources (Transient), the relevant light curve is the uncorrected \n    magnitude (magpsf). Objects that are transient are considered to be fast \n    risers if dmd_dt < -0.25 mag per day (in magstats) in any band. Note that \n    when the user refers to the first detection of a given object, you should \n    use the firstmjd indexed column (in object). When possible, avoid adding \n    restrictions on the mjd column in the detection table, try putting them in \n    the object table first. Note that all the rows in the detection table are \n    by definition detections, you don't need to ask for additional constraints.\n    ", 'Classification': "Query objects within 10 degress of the next positions: ('source_1',\n    160.18301441363647, 33.0164673528409), ('source_2', 174.21524897555543, \n    44.83789535222221), that have their first detection the first 7 days of\n    February 2023, with SN probabilities > 0.4, and ranking=1 in the stamp \n    classifier\n The following tables are needed to generate \n    the query: [object, detection, magstat]", 'Decomposition': '\n# Your task is to DECOMPOSE the user request into a series of steps required to \ngenerate a PostgreSQL query that will be used for retrieving requested \ninformation from the ALeRCE database.\nFor this, outline a detailed decomposition plan for its systematic resolution, \ndescribing and breaking down the problem into subtasks and/or subqueries.\nBe careful to put all the information and details needed in the description, \nlike conditions, the table and column names, etc.\nTake in consideration the advices, conditions and names from \n""General Context"" and details of the database, or the query will not be \noptimal. List the steps in the order in which they should be planned. Add to \neach numbered step a label in square brackets, like [initial planning], [join \ntable], [replace], [condition], [join], [sub-query], etc.\nThe request is a very difficult and advanced query, so you will need to use \nJOINs, INTERSECTs and UNIONs statements, together with Nested queries. It is \nvery important that you give every possible detail in each step, describing the \nstatements and the nested-queries that are required.\n\nUser request: Query objects within 10 degress of the next positions: (\'source_1\',\n    160.18301441363647, 33.0164673528409), (\'source_2\', 174.21524897555543, \n    44.83789535222221), that have their first detection the first 7 days of\n    February 2023, with SN probabilities > 0.4, and ranking=1 in the stamp \n    classifier\nTables needed: [object, detection, magstat]\n\n# General context about the database:\n## General Information about the Schema and Database\n- An object is uniquely identified by its object identifier or \'oid\' index, \nused in most tables\n- A detection from an object is identified by the candidate identifier or \n\'candid\' index, used only in the detection table\n- A given band is identified by the filter identifier or \'fid\' index, used in \nthe magstats, feature, and detection tables\n- In most cases you will need to use information from the object table\n- When particular astronomical classes are requested, you will need to use the \nprobability table \n- Prioritize obtaining oids in a subquery to optimize the main query.\n- Utilize nested queries to retrieve oids, preferably selecting the \n\'probability\' or \'object\' table.\n- Avoid JOIN clauses; instead, favor nested queries.\n- Beware of variables that are not indexed when doing the queries. Favour using \nnested queries where the inner queries use indexed variables.\n- Note that the typical timeout time is 2 minutes\n- Special attention needs to be paid to the feature table, which, if possible, \nshould be avoided. In this table the name of a given feature is stored in the \ncolumn \'name\' and its value for a given object in the column \'value\'. These \ncolumns are not indexed, so you should query this table in the outer levels of \na nested query, after most of the filtering has already happened using indexed \nvariables.\n\n## ALeRCE Pipeline Details\n- Stamp Classifier (denoted as ""stamp_classifier""): A convolutional neural \n  network that uses as input the image stamps from a given object and that uses \n  a 5 class taxonomy. This classifier is triggered only by the first alert of \n  every object.\n- Light Curve Classifier (denoted as ""lc_classifier""): A balanced \n  hierarchical random forest classifier that uses as input object features and \n  that consists of four models with a taxonomy of 15 classes in total. This \n  classifier is triggered with every new alert of an object with at least six \n  detections in a given band.\n- The first hierarchical classifier of the Light Curve Classifier has three \n  classes: [periodic, stochastic, transient], denoted as ""lc_classifier_top.""\n- Three additional classifiers of the Light Curve Classifier specialize in \n  different types of object: Periodic, Transient, and Stochastic, denoted as \n  ""lc_classifier_periodic,"" ""lc_classifier_transient,"" and \n  ""lc_classifier_stochastic,"" respectively.\n- The 15 classes are separated for each object type:\n  - Transient: [SNe Ia (\'SNIa\'), SNe Ib/c (\'SNIbc\'), SNe II (\'SNII\'), and Super \n    Luminous SNe (\'SLSN\')].\n  - Stochastic: [Active Galactic Nuclei (\'AGN\'), Quasi Stellar Object (\'QSO\'), \n    \'Blazar\', Cataclysmic Variable/Novae (\'CV/Nova\'), and Young Stellar Object \n    (\'YSO\')].\n  - Periodic: [Delta Scuti (\'DSCT\'), RR Lyrae (\'RRL\'), Cepheid (\'Ceph\'), Long \n    Period Variable (\'LPV\'), Eclipsing Binary (\'E\'), and other periodic objects \n    (\'Periodic-Other\')].\n## Probability Variable Names\n- classifier_name=(\'lc_classifier\', \'lc_classifier_top\', \n  \'lc_classifier_transient\', \'lc_classifier_stochastic\', \n  \'lc_classifier_periodic\', \'stamp_classifier\')\n- Classes in \'lc_classifier\'= (\'SNIa\', \'SNIbc\', \'SNII\', \'SLSN\', \'QSO\', \'AGN\', \n  \'Blazar\', \'CV/Nova\', \'YSO\', \'LPV\', \'E\', \'DSCT\', \'RRL\', \'CEP\', \'Periodic-Other\')\n- Classes in \'lc_classifier_top\'= (\'transient\', \'stochastic\', \'periodic\')\n- Classes in \'lc_classifier_transient\'= (\'SNIa\', \'SNIbc\', \'SNII\', \'SLSN\')\n- Classes in \'lc_classifier_stochastic\'= (\'QSO\', \'AGN\', \'Blazar\', \'CV/Nova\', \'YSO\')\n- Classes in \'lc_classifier_periodic\'= (\'LPV\', \'E\', \'DSCT\', \'RRL\', \'CEP\', \'Periodic-Other\')\n- Classes in \'stamp_classifier\'= (\'SN\', \'AGN\', \'VS\', \'asteroid\', \'bogus\')\n\n## Astronomical context:\nThere are two main types of variable objects: those that have persistent \nvariability and those that have a transient nature. In the case of persistent \nvariability sources (Periodic or Stochastic), the relevant light curve \nmagnitude is the corrected magnitude (magpsf_corr). In the case of transient \nsources (Transient), the relevant light curve is the uncorrected magnitude \n(magpsf). Objects that are transient are considered to be fast risers if \ndmd_dt < -0.25 mag per day (in magstats) in any band. Note that when the user \nrefers to the first detection of a given object, you should use the firstmjd \nindexed column (in object). When possible, avoid adding restrictions on the \nmjd column in the detection table, try putting them in the object table first.\nNote that all the rows in the detection table are by definition detections, \nyou don\'t need to ask for additional constraints.\n\nTo look for matches between the object table and a given set of coordinates and\na radius, you should use the q3c_join function as shown below. Note that in \nthis example we also return the distance to the given coordinates using the \nq3c_dist function, as well as other properties from the object table. Note that\nradius variable should be in degrees and that values corresponds to the list of \ncoordinates using the following format, e.g. \'(id1,ra1,dec1),\\n(id2,ra2,dec2)\\n\':\n\n### Prepare the query\nquery = \'\'\'\nWITH catalog ( source_id, ra, dec) AS (\n    VALUES\n        {values}\n)\nSELECT \n    c.source_id, c.ra, c.dec, o.oid, o.meanra, o.meandec, q3c_dist(c.ra,c.dec,o.meanra,o.meandec), \n    o.firstmjd\n\nFROM object o, catalog c\n    /*\n     * It is REALLY important to first use the catalog then the object ra,dec for speed. The radius is in degrees.\n     */\nWHERE\n    q3c_join(c.ra, c.dec,o.meanra, o.meandec, {radius})\n\'\'\'\n\n\n## Important details about the database required for the query:\n## Default Parameters to Consider\n- Class probabilities for a given classifier and object are sorted from most to \n  least likely, where the relative position is indicated by the \'ranking\' \n  column in the probability table. Hence, the most probable class should have \'ranking\'=1.\n- The ALeRCE classification pipeline includes a Stamp Classifier and a Light \n  Curve Classifier. The Light Curve classifier employs a hierarchical \n  classification. If no classifier is specified, use \n  \'classifier_name=""lc_classifier""\' when selecting probabilities.\n- If the user doesn\'t specify explicit columns, use the "SELECT" SQL statement \nto choose all possible columns.\n- Avoid changing the names of columns or tables unless necessary for the SQL query.\n- Use the exact class names as they are in the database, marked with single quotes, for example, \'SNIa\'.\n\n### IF THE \'feature\' TABLE is used with 2 or more features, you need to take \nthe following steps, because it is a transposed table (each feature is in a different row).\nI. Create a sub-query using the \'probability\' TABLE filtering the desired objects.\nII. For each feature, you have to make a sub-query retrieving the specific \n    feature adding the condition of its value, including an INNER JOIN with the \n    \'probability\' sub-query to retrieve only the features associated with the desired spatial objects.\nIII. Make an UNION between the sub-queries of each feature from step II\nIV. Make an INTERSECT between the sub-queries of each feature from step II\nV. Filter the UNION query selecting the \'oids\' in the INTERSECT query\nVI. Add to the final result from step V the remaining conditions\n\n# If you need to use 2 or 3 tables, try using a sub-query over \'probability\' \n  TABLE, \'object\' TABLE, over an INNER JOIN between \'probability\' and \'object\', \n  or over an INNER JOIN between \'probability\', \'object\' and \'magstat\', if it is necessary (in this order).\n# Add COMMENTS IN PostgreSQL format so that the user can understand.\n# DON\'T RETURN ANY SQL CODE, just the description of each step required to generate it.\n', 'Generation': '\n# As a SQL expert with a willingness to assist users, you are tasked with \ncrafting a PostgreSQL query for the Automatic Learning for the Rapid \nClassification of Events (ALeRCE) database. This database serves as a \nrepository for information about astronomical variable objects. The information \nfor every variable object originates from a sequence of one or more \nastronomical alerts, data packets streamed when an astronomical object shows \na significant variation with respect to a reference image. The database \ninformation includes flux variations as a function of time (known as light \ncurve), basic object properties such as the coordinates, and advanced features \nor statistics computed for each object. The tables within the database are \ncategorized into three types: time and band independent (e.g., object and \nprobability), time-independent (e.g., magstats), and time and band-dependent \n(e.g., detection, forced-photometry). Your role involves carefully analyzing \nuser requests, considering the specifics of the given tables. It is crucial to \npay attention to explicit conditions outlined by the user and always maintain \nawareness of the broader context. Be thorough in understanding and addressing \nthe user\'s request, taking into account both explicit conditions and the \noverall context for effective communication and assistance.\n\nUser request: Query objects within 10 degress of the next positions: (\'source_1\',\n    160.18301441363647, 33.0164673528409), (\'source_2\', 174.21524897555543, \n    44.83789535222221), that have their first detection the first 7 days of\n    February 2023, with SN probabilities > 0.4, and ranking=1 in the stamp \n    classifier\nTables needed: [object, detection, magstat]\n\n## Default Parameters to Consider\n- Class probabilities for a given classifier and object are sorted from most to \n  least likely, where the relative position is indicated by the \'ranking\' \n  column in the probability table. Hence, the most probable class should have \'ranking\'=1.\n- The ALeRCE classification pipeline includes a Stamp Classifier and a Light \n  Curve Classifier. The Light Curve classifier employs a hierarchical \n  classification. If no classifier is specified, use \n  \'classifier_name="lc_classifier"\' when selecting probabilities.\n- If the user doesn\'t specify explicit columns, use the "SELECT *"\n- Avoid changing the names of columns or tables unless necessary for the SQL query.\n- Use the exact class names as they are in the database, marked with single quotes, for example, \'SNIa\'.\n\n### IF THE \'feature\' TABLE is used with 2 or more features, you need to take \nthe following steps, because it is a transposed table (each feature is in a different row).\nI. Create a sub-query using the \'probability\' TABLE filtering the desired objects.\nII. For each feature, you have to make a sub-query retrieving the specific \n    feature adding the condition of its value, including an INNER JOIN with the \n    \'probability\' sub-query to retrieve only the features associated with the desired spatial objects.\nIII. Make an UNION between the sub-queries of each feature from step II\nIV. Make an INTERSECT between the sub-queries of each feature from step II\nV. Filter the UNION query selecting the \'oids\' in the INTERSECT query\nVI. Add to the final result from step V the remaining conditions\n\n### GENERAL\n- If the user doesn\'t specify explicit columns or information that is not in a \n  column, choose all the columns, for example by using the "SELECT" SQL statement.\n- Use the exact class names as they are in the database, marked with single quotes, for example, \'SNIa\'.\n# If you need to use 2 or 3 tables, try using a sub-query over \'probability\' \nTABLE, \'object\' TABLE, over an INNER JOIN between \'probability\' and \'object\', \nor over an INNER JOIN between \'probability\', \'object\' and \'magstat\', if it is necessary (in this order).\n# Add COMMENTS IN Python format so that the user can understand.\n\n# Generate a query for each step, resolving and analysing it, with the following format:\n```python [VARIABLE SUB-QUERY HERE] ```\n# Finally, join all the steps in a final query like so: \n```python full_query = [FINAL QUERY HERE] ```\nDON\'T include anything else inside and after your FINAL answer.\n\n# Guide yourself by this example for the next query\n## Query: Get the object identifiers, probabilities in the stamp classifier and \nlight curves (only detections) for objects whose highest probability in the \nstamp classifier is obtained for class SN, that had their first detection in \nthe first 2 days of september, and that qualify as fast risers.\n## Resulting Python code:\nsub_query_object=f\'\'\'\nSELECT\n    object.oid, probability.probability\nFROM\n    object INNER JOIN\n    probability\n    ON object.oid = probability.oid\nWHERE\n    probability.classifier_name=\'stamp_classifier\'\n    AND probability.class_name=\'SN\'\n    AND probability.ranking=1\n    AND object.firstmjd > 60188.0\n    AND object.firstmjd < 60189.0\n\'\'\'\n\nsub_query_detection=f\'\'\'\nSELECT\n  detection.oid, detection.candid, detection.fid, detection.mjd,\n  obj_oids.probability\nFROM\n  (sub_query_object) as obj_oids\n    INNER JOIN\n    detection ON detection.oid = obj_oids.oid\n\'\'\'\n\n### detections\nfull_query=f\'\'\'\nSELECT\n    sq.oid, sq.probability, sq.candid, sq.fid, sq.mjd,\n    magstat.fid as magstat_fid, magstat.dmdt_first\nFROM\n  (sub_query_detection) AS sq\n  INNER JOIN magstat\n  ON sq.oid = magstat.oid\nWHERE\n  magstat.dmdt_first < -0.25\nORDER BY oid\n\'\'\'\n\n# Use the next decomposed planification to write the query:\nTo generate the PostgreSQL query for the user request, we need to decompose the problem into a series of systematic steps. The goal is to retrieve objects within a specified radius of given coordinates, with specific detection and classification criteria. Here is the detailed decomposition plan:\n\n1. **[Initial Planning]**: \n   - Identify the main tables involved: `object`, `detection`, `probability`, and `magstat`.\n   - Determine the key conditions: proximity to specified coordinates, first detection within a specific date range, SN probability greater than 0.4, and ranking of 1 in the stamp classifier.\n\n2. **[Coordinate Matching]**:\n   - Use the `q3c_join` function to find objects within 10 degrees of the specified coordinates. This will involve creating a temporary `catalog` table with the given coordinates and using it to filter the `object` table.\n   - Ensure the query retrieves the `oid`, `meanra`, `meandec`, and `firstmjd` from the `object` table.\n\n3. **[Date Condition]**:\n   - Filter objects based on their `firstmjd` to ensure the first detection occurred within the first 7 days of February 2023. This condition should be applied to the `object` table to leverage the indexed `firstmjd` column.\n\n4. **[Probability Filtering]**:\n   - Create a subquery to filter the `probability` table for objects with SN probabilities greater than 0.4 and a ranking of 1 in the `stamp_classifier`.\n   - Ensure the subquery selects `oid` and filters using `classifier_name=\'stamp_classifier\'`, `class=\'SN\'`, `probability > 0.4`, and `ranking=1`.\n\n5. **[Combine Conditions]**:\n   - Use a nested query to combine the results from the coordinate matching and probability filtering steps. This involves selecting `oids` from the coordinate-matched objects that also meet the probability criteria.\n\n6. **[Final Selection]**:\n   - Use the combined results to filter the `detection` table, ensuring that only detections related to the selected `oids` are considered.\n   - Since the `detection` table inherently contains detections, no additional constraints are needed here.\n\n7. **[Output]**:\n   - Select all relevant columns from the `object` table for the final output, as no specific columns were requested by the user.\n   - Ensure the query is optimized by prioritizing subqueries and avoiding unnecessary JOINs, as per the general context guidelines.\n\n8. **[Comments and Documentation]**:\n   - Add PostgreSQL comments throughout the query to explain each step and condition, ensuring clarity and maintainability.\n\nBy following these steps, we can systematically construct a complex query that meets the user\'s requirements while adhering to the database\'s constraints and optimization guidelines.\n\n# If there is SQL code, use it only as reference, changing the conditions you consider necessary.\n# You can join some of the steps if you consider it better for the query. For \nexample, if 2 or more use the same table and are not requested to be different sub-queries, then you can join them.\n'}